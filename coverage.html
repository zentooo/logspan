
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>logger: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/zentooo/logspan/pkg/logger/base_logger.go (100.0%)</option>
				
				<option value="file1">github.com/zentooo/logspan/pkg/logger/config.go (84.2%)</option>
				
				<option value="file2">github.com/zentooo/logspan/pkg/logger/context.go (60.0%)</option>
				
				<option value="file3">github.com/zentooo/logspan/pkg/logger/context_logger.go (94.4%)</option>
				
				<option value="file4">github.com/zentooo/logspan/pkg/logger/direct_logger.go (89.7%)</option>
				
				<option value="file5">github.com/zentooo/logspan/pkg/logger/entry.go (87.5%)</option>
				
				<option value="file6">github.com/zentooo/logspan/pkg/logger/formatter_utils.go (100.0%)</option>
				
				<option value="file7">github.com/zentooo/logspan/pkg/logger/level.go (100.0%)</option>
				
				<option value="file8">github.com/zentooo/logspan/pkg/logger/middleware.go (100.0%)</option>
				
				<option value="file9">github.com/zentooo/logspan/pkg/logger/middleware_manager.go (100.0%)</option>
				
				<option value="file10">github.com/zentooo/logspan/pkg/logger/password_masking_middleware.go (96.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package logger

import (
        "io"
        "sync"

        "github.com/zentooo/logspan/pkg/formatter"
)

// BaseLogger contains common fields and methods shared by DirectLogger and ContextLogger
type BaseLogger struct {
        output    io.Writer
        minLevel  LogLevel
        formatter formatter.Formatter
        mutex     sync.Mutex
}

// newBaseLogger creates a new BaseLogger with default settings
func newBaseLogger() BaseLogger <span class="cov8" title="1">{
        return BaseLogger{
                output:    nil, // Will be set by the specific logger
                minLevel:  InfoLevel,
                formatter: createDefaultFormatter(),
        }
}</span>

// SetOutput sets the output writer for the logger
func (b *BaseLogger) SetOutput(w io.Writer) <span class="cov8" title="1">{
        b.mutex.Lock()
        defer b.mutex.Unlock()
        b.output = w
}</span>

// SetLevel sets the minimum log level for filtering
func (b *BaseLogger) SetLevel(level LogLevel) <span class="cov8" title="1">{
        b.mutex.Lock()
        defer b.mutex.Unlock()
        b.minLevel = level
}</span>

// SetFormatter sets the formatter for the logger
func (b *BaseLogger) SetFormatter(f formatter.Formatter) <span class="cov8" title="1">{
        b.mutex.Lock()
        defer b.mutex.Unlock()
        b.formatter = f
}</span>

// SetLevelFromString sets the minimum log level from a string
func (b *BaseLogger) SetLevelFromString(level string) <span class="cov8" title="1">{
        b.SetLevel(ParseLogLevel(level))
}</span>

// isLevelEnabled checks if the given level should be logged
func (b *BaseLogger) isLevelEnabled(level LogLevel) bool <span class="cov8" title="1">{
        return IsLevelEnabled(level, b.minLevel)
}</span>

// getOutput returns the current output writer (thread-safe)
func (b *BaseLogger) getOutput() io.Writer <span class="cov8" title="1">{
        b.mutex.Lock()
        defer b.mutex.Unlock()
        return b.output
}</span>

// getFormatter returns the current formatter (thread-safe)
func (b *BaseLogger) getFormatter() formatter.Formatter <span class="cov8" title="1">{
        b.mutex.Lock()
        defer b.mutex.Unlock()
        return b.formatter
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package logger

import (
        "io"
        "os"
        "sync"

        "github.com/zentooo/logspan/pkg/formatter"
)

// Config holds the global configuration for the logger
type Config struct {
        // MinLevel sets the minimum log level for filtering
        MinLevel LogLevel

        // Output sets the output writer for logs
        Output io.Writer

        // EnableSourceInfo enables source file and line information in logs
        EnableSourceInfo bool

        // PrettifyJSON enables pretty-printing of JSON output with indentation
        PrettifyJSON bool

        // MaxLogEntries sets the maximum number of log entries to accumulate in ContextLogger
        // before automatically flushing. 0 means no limit (default behavior)
        MaxLogEntries int
}

// DefaultConfig returns a default configuration
func DefaultConfig() Config <span class="cov8" title="1">{
        return Config{
                MinLevel:         InfoLevel,
                Output:           os.Stdout,
                EnableSourceInfo: false,
                PrettifyJSON:     false,
                MaxLogEntries:    1000, // Default to 1000 entries before auto-flush
        }
}</span>

// Global configuration
var (
        globalConfig Config
        configMutex  sync.RWMutex
        initialized  bool
)

// Init initializes the global logger configuration
func Init(config Config) <span class="cov8" title="1">{
        configMutex.Lock()
        defer configMutex.Unlock()

        globalConfig = config

        // Update global direct logger with new configuration
        if directLogger, ok := D.(*DirectLogger); ok </span><span class="cov8" title="1">{
                directLogger.SetOutput(globalConfig.Output)
                directLogger.SetLevel(globalConfig.MinLevel)

                // Update formatter based on PrettifyJSON setting (avoid calling createDefaultFormatter to prevent deadlock)
                var jsonFormatter formatter.Formatter
                if globalConfig.PrettifyJSON </span><span class="cov8" title="1">{
                        jsonFormatter = formatter.NewJSONFormatterWithIndent("  ")
                }</span> else<span class="cov8" title="1"> {
                        jsonFormatter = formatter.NewJSONFormatter()
                }</span>
                <span class="cov8" title="1">directLogger.SetFormatter(jsonFormatter)</span>
        }

        <span class="cov8" title="1">initialized = true</span>
}

// GetConfig returns a copy of the current global configuration
func GetConfig() Config <span class="cov8" title="1">{
        configMutex.RLock()
        defer configMutex.RUnlock()
        return globalConfig
}</span>

// IsInitialized returns whether the logger has been initialized
func IsInitialized() bool <span class="cov0" title="0">{
        configMutex.RLock()
        defer configMutex.RUnlock()
        return initialized
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package logger

import (
        "context"
)

// contextKey is a private type for context keys to avoid collisions
type contextKey string

const (
        // loggerContextKey is the key used to store the logger in context
        loggerContextKey contextKey = "logger"
)

// WithLogger returns a new context with the logger attached
func WithLogger(ctx context.Context, logger *ContextLogger) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, loggerContextKey, logger)
}</span>

// FromContext retrieves the logger from the context
// If no logger is found, it returns a new ContextLogger
func FromContext(ctx context.Context) *ContextLogger <span class="cov8" title="1">{
        if logger, ok := ctx.Value(loggerContextKey).(*ContextLogger); ok </span><span class="cov8" title="1">{
                return logger
        }</span>
        // Return a new logger if none is found in context
        <span class="cov8" title="1">return NewContextLogger()</span>
}

// AddContextValue adds a field to the logger in the context
func AddContextValue(ctx context.Context, key string, value interface{}) <span class="cov8" title="1">{
        logger := FromContext(ctx)
        logger.AddContextValue(key, value)
}</span>

// AddContextValues adds multiple fields to the logger in the context
func AddContextValues(ctx context.Context, fields map[string]interface{}) <span class="cov0" title="0">{
        logger := FromContext(ctx)
        logger.AddContextValues(fields)
}</span>

// Infof logs an info message using the logger from context
func Infof(ctx context.Context, format string, args ...interface{}) <span class="cov8" title="1">{
        logger := FromContext(ctx)
        logger.Infof(format, args...)
}</span>

// Debugf logs a debug message using the logger from context
func Debugf(ctx context.Context, format string, args ...interface{}) <span class="cov0" title="0">{
        logger := FromContext(ctx)
        logger.Debugf(format, args...)
}</span>

// Warnf logs a warning message using the logger from context
func Warnf(ctx context.Context, format string, args ...interface{}) <span class="cov0" title="0">{
        logger := FromContext(ctx)
        logger.Warnf(format, args...)
}</span>

// Errorf logs an error message using the logger from context
func Errorf(ctx context.Context, format string, args ...interface{}) <span class="cov8" title="1">{
        logger := FromContext(ctx)
        logger.Errorf(format, args...)
}</span>

// Criticalf logs a critical message using the logger from context
func Criticalf(ctx context.Context, format string, args ...interface{}) <span class="cov0" title="0">{
        logger := FromContext(ctx)
        logger.Criticalf(format, args...)
}</span>

// FlushContext flushes the logger from the context
func FlushContext(ctx context.Context) <span class="cov8" title="1">{
        logger := FromContext(ctx)
        logger.Flush()
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package logger

import (
        "fmt"
        "os"
        "runtime"
        "strings"
        "time"
)

// ContextLogger implements context-based logging with log aggregation
type ContextLogger struct {
        BaseLogger
        entries    []*LogEntry
        fields     map[string]interface{}
        startTime  time.Time
        maxEntries int // Maximum number of entries before auto-flush
}

// NewContextLogger creates a new ContextLogger instance
func NewContextLogger() *ContextLogger <span class="cov8" title="1">{
        // Get global config to determine formatter settings
        config := GetConfig()

        base := newBaseLogger()
        base.output = os.Stdout // Set default output for ContextLogger
        base.minLevel = config.MinLevel

        return &amp;ContextLogger{
                BaseLogger: base,
                entries:    make([]*LogEntry, 0),
                fields:     make(map[string]interface{}),
                startTime:  time.Now(),
                maxEntries: config.MaxLogEntries,
        }
}</span>

// addEntry adds a log entry to the context logger
func (l *ContextLogger) addEntry(level LogLevel, message string) <span class="cov8" title="1">{
        if !l.isLevelEnabled(level) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">l.mutex.Lock()
        defer l.mutex.Unlock()

        entry := &amp;LogEntry{
                Timestamp: time.Now(),
                Level:     level.String(),
                Message:   message,
        }

        // Add source information if enabled
        config := GetConfig()
        if config.EnableSourceInfo </span><span class="cov8" title="1">{
                // Determine the appropriate skip level by examining the call stack
                skipLevel := 3 // Default for direct ContextLogger method calls

                // Check the call stack to see if we're being called through context.go functions
                for i := 2; i &lt;= 5; i++ </span><span class="cov8" title="1">{
                        if pc, _, _, ok := runtime.Caller(i); ok </span><span class="cov8" title="1">{
                                if fn := runtime.FuncForPC(pc); fn != nil </span><span class="cov8" title="1">{
                                        funcName := fn.Name()
                                        // If we find a context.go function in the stack, use skip level 4
                                        if strings.Contains(funcName, "/pkg/logger.Infof") ||
                                                strings.Contains(funcName, "/pkg/logger.Debugf") ||
                                                strings.Contains(funcName, "/pkg/logger.Warnf") ||
                                                strings.Contains(funcName, "/pkg/logger.Errorf") ||
                                                strings.Contains(funcName, "/pkg/logger.Criticalf") </span><span class="cov8" title="1">{
                                                skipLevel = 4
                                                break</span>
                                        }
                                }
                        }
                }

                <span class="cov8" title="1">sourceInfo := getSourceInfo(skipLevel)
                entry.Funcname = sourceInfo.Funcname
                entry.Filename = sourceInfo.Filename
                entry.Fileline = sourceInfo.Fileline</span>
        }

        // Process through global middleware chain
        <span class="cov8" title="1">processWithGlobalMiddleware(entry, func(processedEntry *LogEntry) </span><span class="cov8" title="1">{
                l.entries = append(l.entries, processedEntry)

                // Check if we need to auto-flush due to entry limit
                if l.maxEntries &gt; 0 &amp;&amp; len(l.entries) &gt;= l.maxEntries </span><span class="cov8" title="1">{
                        l.flushInternal()
                }</span>
        })
}

// flushInternal performs the flush operation without acquiring the mutex
// This method assumes the mutex is already held by the caller
func (l *ContextLogger) flushInternal() <span class="cov8" title="1">{
        if l.output == nil || len(l.entries) == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">endTime := time.Now()

        // Use the formatter (default or explicitly set)
        jsonData, err := formatLogOutput(l.entries, l.fields, l.startTime, endTime, l.formatter)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to simple output if formatting fails
                _, _ = fmt.Fprintf(l.output, "Error formatting log: %v\n", err)
                return
        }</span>

        <span class="cov8" title="1">if _, err := fmt.Fprintf(l.output, "%s\n", jsonData); err != nil </span><span class="cov0" title="0">{
                // If writing fails, try to write an error message
                // This is a best-effort attempt since the output might be broken
                // We intentionally ignore any error from this fallback write
                _, _ = fmt.Fprintf(l.output, "Error writing log output: %v\n", err)
        }</span>

        // Clear entries after flushing and reset start time
        <span class="cov8" title="1">l.entries = l.entries[:0] // Clear slice but keep capacity
        l.startTime = time.Now()</span>  // Reset start time for next batch
}

// Flush outputs all accumulated log entries as a single JSON
func (l *ContextLogger) Flush() <span class="cov8" title="1">{
        l.mutex.Lock()
        defer l.mutex.Unlock()
        l.flushInternal()
}</span>

// AddContextValue adds a field to the context
func (l *ContextLogger) AddContextValue(key string, value interface{}) <span class="cov8" title="1">{
        l.mutex.Lock()
        defer l.mutex.Unlock()
        l.fields[key] = value
}</span>

// AddContextValues adds multiple fields to the context
func (l *ContextLogger) AddContextValues(fields map[string]interface{}) <span class="cov8" title="1">{
        l.mutex.Lock()
        defer l.mutex.Unlock()
        for k, v := range fields </span><span class="cov8" title="1">{
                l.fields[k] = v
        }</span>
}

// Debugf logs a debug message
func (l *ContextLogger) Debugf(format string, args ...interface{}) <span class="cov8" title="1">{
        l.addEntry(DebugLevel, fmt.Sprintf(format, args...))
}</span>

// Infof logs an info message
func (l *ContextLogger) Infof(format string, args ...interface{}) <span class="cov8" title="1">{
        l.addEntry(InfoLevel, fmt.Sprintf(format, args...))
}</span>

// Warnf logs a warning message
func (l *ContextLogger) Warnf(format string, args ...interface{}) <span class="cov8" title="1">{
        l.addEntry(WarnLevel, fmt.Sprintf(format, args...))
}</span>

// Errorf logs an error message
func (l *ContextLogger) Errorf(format string, args ...interface{}) <span class="cov8" title="1">{
        l.addEntry(ErrorLevel, fmt.Sprintf(format, args...))
}</span>

// Criticalf logs a critical message
func (l *ContextLogger) Criticalf(format string, args ...interface{}) <span class="cov8" title="1">{
        l.addEntry(CriticalLevel, fmt.Sprintf(format, args...))
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package logger

import (
        "fmt"
        "os"
        "time"
)

// DirectLogger implements the Logger interface for direct logging without context
type DirectLogger struct {
        BaseLogger
}

// NewDirectLogger creates a new DirectLogger instance
func NewDirectLogger() *DirectLogger <span class="cov8" title="1">{
        base := newBaseLogger()
        base.output = os.Stdout // Set default output for DirectLogger
        return &amp;DirectLogger{
                BaseLogger: base,
        }
}</span>

// logf writes a log entry with the given level and message in structured format
func (l *DirectLogger) logf(level LogLevel, format string, args ...interface{}) <span class="cov8" title="1">{
        if !l.isLevelEnabled(level) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">l.mutex.Lock()
        defer l.mutex.Unlock()

        // Do nothing if output is nil
        if l.output == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">now := time.Now()
        entry := &amp;LogEntry{
                Timestamp: now,
                Level:     level.String(),
                Message:   fmt.Sprintf(format, args...),
        }

        // Add source information if enabled
        config := GetConfig()
        if config.EnableSourceInfo </span><span class="cov8" title="1">{
                // Skip levels: getSourceInfo(0) -&gt; logf(1) -&gt; Infof/Debugf/etc(2) -&gt; actual caller(3)
                sourceInfo := getSourceInfo(3)
                entry.Funcname = sourceInfo.Funcname
                entry.Filename = sourceInfo.Filename
                entry.Fileline = sourceInfo.Fileline
        }</span>

        // Process through global middleware chain
        <span class="cov8" title="1">processWithGlobalMiddleware(entry, func(processedEntry *LogEntry) </span><span class="cov8" title="1">{
                // Use the formatter (default or explicitly set)
                jsonData, err := formatLogOutput([]*LogEntry{processedEntry}, make(map[string]interface{}), processedEntry.Timestamp, processedEntry.Timestamp, l.formatter)
                if err != nil </span><span class="cov0" title="0">{
                        _, _ = fmt.Fprintf(l.output, "Error formatting log: %v\n", err)
                        return
                }</span>

                <span class="cov8" title="1">if _, err := fmt.Fprintf(l.output, "%s\n", jsonData); err != nil </span><span class="cov0" title="0">{
                        // If writing fails, try to write an error message
                        // This is a best-effort attempt since the output might be broken
                        // We intentionally ignore any error from this fallback write
                        _, _ = fmt.Fprintf(l.output, "Error writing log output: %v\n", err)
                }</span>
        })
}

// Debugf logs a debug message
func (l *DirectLogger) Debugf(format string, args ...interface{}) <span class="cov8" title="1">{
        l.logf(DebugLevel, format, args...)
}</span>

// Infof logs an info message
func (l *DirectLogger) Infof(format string, args ...interface{}) <span class="cov8" title="1">{
        l.logf(InfoLevel, format, args...)
}</span>

// Warnf logs a warning message
func (l *DirectLogger) Warnf(format string, args ...interface{}) <span class="cov8" title="1">{
        l.logf(WarnLevel, format, args...)
}</span>

// Errorf logs an error message
func (l *DirectLogger) Errorf(format string, args ...interface{}) <span class="cov8" title="1">{
        l.logf(ErrorLevel, format, args...)
}</span>

// Criticalf logs a critical message
func (l *DirectLogger) Criticalf(format string, args ...interface{}) <span class="cov8" title="1">{
        l.logf(CriticalLevel, format, args...)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package logger

import (
        "path/filepath"
        "runtime"
        "time"
)

// LogEntry represents a single log entry
type LogEntry struct {
        Timestamp time.Time `json:"timestamp"`
        Level     string    `json:"level"`
        Message   string    `json:"message"`
        Funcname  string    `json:"funcname,omitempty"`
        Filename  string    `json:"filename,omitempty"`
        Fileline  int       `json:"fileline,omitempty"`
}

// SourceInfo holds source code location information
type SourceInfo struct {
        Funcname string
        Filename string
        Fileline int
}

// getSourceInfo retrieves source information using runtime.Caller
// skip indicates how many stack frames to skip (0 = current function, 1 = caller, etc.)
func getSourceInfo(skip int) *SourceInfo <span class="cov8" title="1">{
        pc, file, line, ok := runtime.Caller(skip)
        if !ok </span><span class="cov0" title="0">{
                return &amp;SourceInfo{}
        }</span>

        // Get function name
        <span class="cov8" title="1">funcName := "unknown"
        if fn := runtime.FuncForPC(pc); fn != nil </span><span class="cov8" title="1">{
                funcName = fn.Name()
        }</span>

        // Get base filename (without full path)
        <span class="cov8" title="1">filename := filepath.Base(file)

        return &amp;SourceInfo{
                Funcname: funcName,
                Filename: filename,
                Fileline: line,
        }</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package logger

import (
        "time"

        "github.com/zentooo/logspan/pkg/formatter"
)

// createDefaultFormatter creates a default formatter based on global configuration
func createDefaultFormatter() formatter.Formatter <span class="cov8" title="1">{
        config := GetConfig()
        if config.PrettifyJSON </span><span class="cov8" title="1">{
                return formatter.NewJSONFormatterWithIndent("  ")
        }</span>
        <span class="cov8" title="1">return formatter.NewJSONFormatter()</span>
}

// formatLogOutput creates a LogOutput structure and formats it using the given formatter
// If formatter is nil, uses default JSONFormatter
func formatLogOutput(entries []*LogEntry, contextFields map[string]interface{}, startTime, endTime time.Time, f formatter.Formatter) ([]byte, error) <span class="cov8" title="1">{
        elapsed := endTime.Sub(startTime).Milliseconds()

        // Find the highest severity level
        maxSeverity := DebugLevel
        for _, entry := range entries </span><span class="cov8" title="1">{
                entryLevel := ParseLogLevel(entry.Level)
                maxSeverity = GetHigherLevel(entryLevel, maxSeverity)
        }</span>

        // Convert logger.LogEntry to formatter.LogEntry
        <span class="cov8" title="1">formatterEntries := make([]*formatter.LogEntry, len(entries))
        for i, entry := range entries </span><span class="cov8" title="1">{
                formatterEntries[i] = &amp;formatter.LogEntry{
                        Timestamp: entry.Timestamp,
                        Level:     entry.Level,
                        Message:   entry.Message,
                        Funcname:  entry.Funcname,
                        Filename:  entry.Filename,
                        Fileline:  entry.Fileline,
                }
        }</span>

        // Create LogOutput structure
        <span class="cov8" title="1">logOutput := &amp;formatter.LogOutput{
                Type:    "request",
                Context: contextFields,
                Runtime: formatter.RuntimeInfo{
                        Severity:  maxSeverity.String(),
                        StartTime: startTime.Format(time.RFC3339Nano),
                        EndTime:   endTime.Format(time.RFC3339Nano),
                        Elapsed:   elapsed,
                        Lines:     formatterEntries,
                },
        }

        // Use provided formatter or default JSONFormatter
        if f == nil </span><span class="cov8" title="1">{
                // Use default JSONFormatter with prettify setting from global config
                f = createDefaultFormatter()
        }</span>

        <span class="cov8" title="1">return f.Format(logOutput)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package logger

// LogLevel represents the severity level of a log entry
type LogLevel int

const (
        // DebugLevel is the lowest level, used for detailed debugging information
        DebugLevel LogLevel = iota
        // InfoLevel is used for general informational messages
        InfoLevel
        // WarnLevel is used for warning messages
        WarnLevel
        // ErrorLevel is used for error messages
        ErrorLevel
        // CriticalLevel is the highest level, used for critical error messages
        CriticalLevel
)

// Log level string constants
const (
        debugLevelString    = "DEBUG"
        infoLevelString     = "INFO"
        warnLevelString     = "WARN"
        errorLevelString    = "ERROR"
        criticalLevelString = "CRITICAL"
)

// String returns the string representation of the log level
func (l LogLevel) String() string <span class="cov8" title="1">{
        switch l </span>{
        case DebugLevel:<span class="cov8" title="1">
                return debugLevelString</span>
        case InfoLevel:<span class="cov8" title="1">
                return infoLevelString</span>
        case WarnLevel:<span class="cov8" title="1">
                return warnLevelString</span>
        case ErrorLevel:<span class="cov8" title="1">
                return errorLevelString</span>
        case CriticalLevel:<span class="cov8" title="1">
                return criticalLevelString</span>
        default:<span class="cov8" title="1">
                return "UNKNOWN"</span>
        }
}

// ParseLogLevel parses a string into a LogLevel
func ParseLogLevel(level string) LogLevel <span class="cov8" title="1">{
        switch level </span>{
        case debugLevelString:<span class="cov8" title="1">
                return DebugLevel</span>
        case infoLevelString:<span class="cov8" title="1">
                return InfoLevel</span>
        case warnLevelString:<span class="cov8" title="1">
                return WarnLevel</span>
        case errorLevelString:<span class="cov8" title="1">
                return ErrorLevel</span>
        case criticalLevelString:<span class="cov8" title="1">
                return CriticalLevel</span>
        default:<span class="cov8" title="1">
                return InfoLevel</span> // Default to INFO level
        }
}

// GreaterThan returns true if this log level is greater than the other level
func (l LogLevel) GreaterThan(other LogLevel) bool <span class="cov8" title="1">{
        return l &gt; other
}</span>

// GreaterThanOrEqual returns true if this log level is greater than or equal to the other level
func (l LogLevel) GreaterThanOrEqual(other LogLevel) bool <span class="cov8" title="1">{
        return l &gt;= other
}</span>

// LessThan returns true if this log level is less than the other level
func (l LogLevel) LessThan(other LogLevel) bool <span class="cov8" title="1">{
        return l &lt; other
}</span>

// LessThanOrEqual returns true if this log level is less than or equal to the other level
func (l LogLevel) LessThanOrEqual(other LogLevel) bool <span class="cov8" title="1">{
        return l &lt;= other
}</span>

// IsLevelEnabled checks if the given level should be logged based on the minimum level
func IsLevelEnabled(level, minLevel LogLevel) bool <span class="cov8" title="1">{
        return level.GreaterThanOrEqual(minLevel)
}</span>

// GetHigherLevel returns the higher of two log levels
func GetHigherLevel(level1, level2 LogLevel) LogLevel <span class="cov8" title="1">{
        if level1.GreaterThan(level2) </span><span class="cov8" title="1">{
                return level1
        }</span>
        <span class="cov8" title="1">return level2</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package logger

// Middleware defines the interface for log entry processing middleware
// Middleware receives a LogEntry and a next function, processes the entry,
// and calls next to continue the chain
type Middleware func(entry *LogEntry, next func(*LogEntry))

// MiddlewareChain manages a chain of middleware functions
type MiddlewareChain struct {
        middlewares []Middleware
}

// NewMiddlewareChain creates a new middleware chain
func NewMiddlewareChain() *MiddlewareChain <span class="cov8" title="1">{
        return &amp;MiddlewareChain{
                middlewares: make([]Middleware, 0),
        }
}</span>

// Add appends a middleware to the chain
func (mc *MiddlewareChain) Add(middleware Middleware) <span class="cov8" title="1">{
        mc.middlewares = append(mc.middlewares, middleware)
}</span>

// Process executes the middleware chain on a log entry
// The final function in the chain is called when all middleware have been processed
func (mc *MiddlewareChain) Process(entry *LogEntry, final func(*LogEntry)) <span class="cov8" title="1">{
        if len(mc.middlewares) == 0 </span><span class="cov8" title="1">{
                final(entry)
                return
        }</span>

        // Build the chain from the end backwards
        <span class="cov8" title="1">next := final
        for i := len(mc.middlewares) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                middleware := mc.middlewares[i]
                currentNext := next
                next = func(e *LogEntry) </span><span class="cov8" title="1">{
                        middleware(e, currentNext)
                }</span>
        }

        // Execute the chain
        <span class="cov8" title="1">next(entry)</span>
}

// Clear removes all middleware from the chain
func (mc *MiddlewareChain) Clear() <span class="cov8" title="1">{
        mc.middlewares = mc.middlewares[:0]
}</span>

// Count returns the number of middleware in the chain
func (mc *MiddlewareChain) Count() int <span class="cov8" title="1">{
        return len(mc.middlewares)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package logger

import (
        "sync"
)

// Global middleware management
var (
        globalMiddlewareChain *MiddlewareChain
        middlewareMutex       sync.RWMutex
        middlewareOnce        sync.Once
)

// ensureMiddlewareChain ensures the global middleware chain is initialized
func ensureMiddlewareChain() <span class="cov8" title="1">{
        middlewareOnce.Do(func() </span><span class="cov8" title="1">{
                globalMiddlewareChain = NewMiddlewareChain()
        }</span>)
}

// AddMiddleware adds a middleware to the global middleware chain
// This middleware will be applied to all log entries processed by the logger
func AddMiddleware(middleware Middleware) <span class="cov8" title="1">{
        ensureMiddlewareChain()
        middlewareMutex.Lock()
        defer middlewareMutex.Unlock()
        globalMiddlewareChain.Add(middleware)
}</span>

// ClearMiddleware removes all middleware from the global chain
func ClearMiddleware() <span class="cov8" title="1">{
        ensureMiddlewareChain()
        middlewareMutex.Lock()
        defer middlewareMutex.Unlock()
        globalMiddlewareChain.Clear()
}</span>

// GetMiddlewareCount returns the number of middleware in the global chain
func GetMiddlewareCount() int <span class="cov8" title="1">{
        ensureMiddlewareChain()
        middlewareMutex.RLock()
        defer middlewareMutex.RUnlock()
        return globalMiddlewareChain.Count()
}</span>

// processWithGlobalMiddleware processes a log entry through the global middleware chain
func processWithGlobalMiddleware(entry *LogEntry, final func(*LogEntry)) <span class="cov8" title="1">{
        ensureMiddlewareChain()
        middlewareMutex.RLock()
        defer middlewareMutex.RUnlock()
        globalMiddlewareChain.Process(entry, final)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package logger

import (
        "regexp"
        "strings"
)

// PasswordMaskingMiddleware creates a middleware that masks password-related information
// in log entries. It searches for password patterns in both message and fields.
type PasswordMaskingMiddleware struct {
        // MaskString is the string used to replace password values (default: "***")
        MaskString string

        // PasswordKeys are field keys that should be masked (case-insensitive)
        PasswordKeys []string

        // PasswordPatterns are regex patterns to detect passwords in messages
        PasswordPatterns []*regexp.Regexp
}

// NewPasswordMaskingMiddleware creates a new password masking middleware with default settings
func NewPasswordMaskingMiddleware() *PasswordMaskingMiddleware <span class="cov8" title="1">{
        return &amp;PasswordMaskingMiddleware{
                MaskString: "***",
                PasswordKeys: []string{
                        "password", "passwd", "pwd", "pass",
                        "secret", "token", "key", "auth",
                        "credential", "credentials", "api_key",
                        "access_token", "refresh_token",
                },
                PasswordPatterns: []*regexp.Regexp{
                        // Pattern for "password=value" or "password: value"
                        regexp.MustCompile(`(?i)(password|passwd|pwd|pass|secret|token|key|auth|credential|api_key|access_token|refresh_token)[\s]*[=:]\s*[^\s]+`),
                        // Pattern for JSON-like structures: "password":"value"
                        regexp.MustCompile(`(?i)"(password|passwd|pwd|pass|secret|token|key|auth|credential|api_key|access_token|refresh_token)"\s*:\s*"[^"]+"`),
                },
        }
}</span>

// WithMaskString sets a custom mask string
func (pmm *PasswordMaskingMiddleware) WithMaskString(maskString string) *PasswordMaskingMiddleware <span class="cov8" title="1">{
        pmm.MaskString = maskString
        return pmm
}</span>

// WithPasswordKeys sets custom password field keys
func (pmm *PasswordMaskingMiddleware) WithPasswordKeys(keys []string) *PasswordMaskingMiddleware <span class="cov8" title="1">{
        pmm.PasswordKeys = keys
        return pmm
}</span>

// AddPasswordKey adds a password field key to the existing list
func (pmm *PasswordMaskingMiddleware) AddPasswordKey(key string) *PasswordMaskingMiddleware <span class="cov8" title="1">{
        pmm.PasswordKeys = append(pmm.PasswordKeys, key)
        return pmm
}</span>

// AddPasswordPattern adds a regex pattern for password detection in messages
func (pmm *PasswordMaskingMiddleware) AddPasswordPattern(pattern *regexp.Regexp) *PasswordMaskingMiddleware <span class="cov8" title="1">{
        pmm.PasswordPatterns = append(pmm.PasswordPatterns, pattern)
        return pmm
}</span>

// Middleware returns the middleware function
func (pmm *PasswordMaskingMiddleware) Middleware() Middleware <span class="cov8" title="1">{
        return func(entry *LogEntry, next func(*LogEntry)) </span><span class="cov8" title="1">{
                // Mask passwords in message
                entry.Message = pmm.maskPasswordsInMessage(entry.Message)

                // Continue to next middleware
                next(entry)
        }</span>
}

// maskPasswordsInMessage masks password patterns in the message string
func (pmm *PasswordMaskingMiddleware) maskPasswordsInMessage(message string) string <span class="cov8" title="1">{
        result := message

        for _, pattern := range pmm.PasswordPatterns </span><span class="cov8" title="1">{
                result = pattern.ReplaceAllStringFunc(result, func(match string) string </span><span class="cov8" title="1">{
                        // Find the separator (= or :) and replace everything after it
                        if strings.Contains(match, "=") </span><span class="cov8" title="1">{
                                parts := strings.SplitN(match, "=", 2)
                                if len(parts) == 2 </span><span class="cov8" title="1">{
                                        return parts[0] + "=" + pmm.MaskString
                                }</span>
                        } else<span class="cov8" title="1"> if strings.Contains(match, ":") </span><span class="cov8" title="1">{
                                parts := strings.SplitN(match, ":", 2)
                                if len(parts) == 2 </span><span class="cov8" title="1">{
                                        // Handle JSON-like format: preserve quotes if they exist
                                        value := strings.TrimSpace(parts[1])
                                        if strings.HasPrefix(value, `"`) &amp;&amp; strings.HasSuffix(value, `"`) </span><span class="cov8" title="1">{
                                                return parts[0] + ":\"" + pmm.MaskString + "\""
                                        }</span>
                                        <span class="cov8" title="1">return parts[0] + ": " + pmm.MaskString</span>
                                }
                        }
                        <span class="cov0" title="0">return pmm.MaskString</span>
                })
        }

        <span class="cov8" title="1">return result</span>
}

// isPasswordKey checks if a key is considered a password field (case-insensitive)
func (pmm *PasswordMaskingMiddleware) isPasswordKey(key string) bool <span class="cov8" title="1">{
        for _, passwordKey := range pmm.PasswordKeys </span><span class="cov8" title="1">{
                if strings.EqualFold(passwordKey, key) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
